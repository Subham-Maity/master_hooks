# NextJs Tutorial for Beginners
## ⚡ Introduction ⚡
### What does NextJs have that React doesn't?

- 📌 Next.js simplifies the development process
- 📌 On top of that it optimizes your web apps

#### 🔗 Features

Here is a table that summarizes some of the differences between React and Next.js based on the search results²³⁴:

| React                                  | Next.js                                  |
|----------------------------------------|------------------------------------------|
| React renders pages on the client side | Next.js renders pages on the server side |

**Client Side** - The client side is the browser. The browser downloads the HTML, CSS, and JavaScript files for a web page. The browser then processes the JavaScript and displays the web page. This is the traditional way of building web apps.

**Server Side** - The server side is the web server. The web server processes the JavaScript and generates HTML, CSS, and JavaScript files. The web server then sends these files to the browser. The browser displays the web page. This is the traditional way of building web sites.

**What is Static Site Generation(SSG) ?**

> Static Site Generation (SSG) is a technique for generating static HTML files from a dynamic website. This is done by pre-rendering the HTML files on the server side and then serving them to the client side. This technique is used to improve the performance of a website by reducing the number of requests made to the server.
- In Next.js, you can use the `getStaticProps` function to generate static HTML files for your website. This function is called at build time and it returns an object with the props that will be passed to the page component. The props are then used to generate the static HTML files for the website.

### ➡️ SSR 


❓ **`SSR vs CSR` Which one is better and why?**

- When a user requests a web page, the browser downloads the HTML, CSS, and JavaScript files for the web page. The browser then processes the JavaScript and displays the web page. This is the traditional way of building web apps.

- On the other hand, when a user requests a web page, the web server processes the JavaScript and generates HTML, CSS, and JavaScript files. The web server then sends these files to the browser. The browser displays the web page. This is known as Server-Side Rendering (SSR).

> SSR has become a widely adopted technique to enhance the performance and SEO of web applications. Next.js is a React framework that allows you to choose between Static Site Generation (SSG) and SSR for each page of your application. When using SSR with Next.js, it makes it simple with response helpers. For this reason, Next.js can be faster and more SEO-friendly than traditional React applications that do not use SSR.


### ➡️  SEO?

- When a web page is rendered dynamically on the client-side, it means that the content of the page is generated by JavaScript running in the user’s browser. This can make it difficult for search engines to crawl and index the content of the page, which can affect search performance.

- Next.js addresses this issue by using Server-Side Rendering (SSR). With SSR, the web server processes the JavaScript and generates HTML, CSS, and JavaScript files. The web server then sends these files to the browser. The browser displays the pre-rendered web page. This makes it easier for search engines to crawl and index the content of the page, leading to improved SEO.

- Some of the benefits of using Next.js for SEO include increased organic traffic, enhanced user experience, credibility and trustworthiness, and a competitive advantage. By using Next.js and SSR, you can improve the search performance of your web application.

  - Increased organic traffic
  - Enhanced user experience
  - Credibility & trustworthiness
  - Competitive advantage

### ➡️ Routing

🎉 **How do we create different page routes in React?**
- We have to create additional package called `react-router-dom` and then we have to create a separate file for routing and then we have to import that file in our main file.

Example:

```jsx
import React from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';
import Contact from './pages/Contact';
import Error from './pages/Error';
import Navbar from './components/Navbar';

const App = () => {
  return (
    <Router>
      <Navbar />
      <Switch>
        <Route exact path='/'>
          <Home />
        </Route>
        <Route path='/about'>
          <About />
        </Route>
        <Route path='/contact'>
          <Contact />
        </Route>
        <Route path='*'>
          <Error />
        </Route>
      </Switch>
    </Router>
  );
};

export default App;
```
🎉 **But in NextJs we don't have to do all this stuff then how do we create routes in NextJs?**

-  Next.js uses a file-based routing system. This means that the routing is handled by the file system. Each folder in the `pages` directory becomes a route and the folder name becomes the route name.

For example, if you have a `pages` directory with the following structure:
```
pages
├── blog
├── about
├── contact
├── services
└── index.js
```
You will have 4 routes and one `index.js` file which is your home page. If you visit `http://localhost:3000/about`, it will show you the about page and if you visit `http://localhost:3000/services`, it will show you the services page. This is how you create routes in Next.js without needing any additional package.


> Dynamic routing is used when you need to create routes with dynamic parameters. This means that the route can change based on the data that is passed to it. Dynamic routing is useful when you have a large number of pages that share a similar structure but have different data.

> For example, let's say you have a blog and you want to create a route for each blog post. Instead of creating a separate route for each blog post, you can create a dynamic route that takes the post ID as a parameter. This way, you can use the same route to display different blog posts based on the ID that is passed to it.

> In Next.js, you can create dynamic routes by creating a file with square brackets in the `pages` directory. For example, if you create a file called `[id].js` inside the `pages` directory, then it will be accessible at `/:id`. You can then use the `useRouter` hook from `next/router` to access the dynamic route parameter and use it to fetch and display the data for the corresponding blog post.
- Dynamic routes are also supported by Next.js. You can create a file with square brackets in the `pages` directory to create a dynamic route in Next.js. For example, if you create a file called `[id].js` inside the `pages` directory, then it will be accessible at `/:id`. Here's an example of how to create a dynamic route in Next.js:

```jsx
// pages/[id].js
import { useRouter } from 'next/router';

const Post = () => {
  const router = useRouter();
  const { id } = router.query;

  return <p>Post: {id}</p>;
};

export default Post;
```
Now if you visit `http://localhost:3000/123`, it will show you "Post: 123". This is how you create dynamic routes in Next.js.

### ➡️ **Fullstack**

From `Next.Js` version 9 developers introduced `API Routes` which allows us to create API endpoints inside our Next.js application. This means that we can create a backend API without having to use a separate server. This is useful for creating full-stack applications with Next.js.

- Enabling the creation of serverless functions to handle API requests
- Serverless APIs in Next.js are a way of creating API endpoints  without having to use a separate server. 
- It allows us to build and deploy APIs 
  - Without managing servers infrastructure
  - Without worrying about scaling up server as traffic grows
  - With this feature you can create API endpoints inside your Next.js application. 

For API endpoints, you have to create a file `route.js` inside `app/example` directory. This file will be accessible at `/api/example/route`. You can then use the `req` and `res` objects to handle the API request and response.

```jsx
// pages/api/example/route.js
export default (req, res) => {
  res.status(200).json({ name: 'John Doe' });
};
```

Now if you visit `http://localhost:3000/api/example/route`, it will show you the following JSON response:

```json
{
  "name": "John Doe"
}
```
> You can also use the `getServerSideProps` function to fetch data from an API endpoint and pass it to the page component as props. This is useful when you want to fetch data from an API endpoint and display it on the page. For example, if you have a blog and you want to display the latest blog posts on the home page, you can use the `getServerSideProps` function to fetch the data from the API endpoint and pass it to the home page component as props.


### ➡️ **Auto Code Splitting**

Code splitting is a technique that breaks down large bundles of JavaScript code into smaller, more manageable chunks that can be loaded as needed. This reduces the initial load time and improves the user experience.

Next.js supports automatic code splitting out-of-the-box. This means that Next.js automatically splits your code into smaller chunks and only loads the code that is needed for the current page.

In addition to automatic code splitting, Next.js also allows you to manually split your code using dynamic imports. You can use the `dynamic` function from `next/dynamic` to dynamically import components. This allows you to load components on demand, further reducing the initial load time.

Here's an example of how to use dynamic imports in Next.js:
```jsx
// pages/index.js
import dynamic from 'next/dynamic';

const DynamicComponent = dynamic(() => import('../components/hello'));

const Home = () => {
  return (
    <div>
      <DynamicComponent />
    </div>
  );
};

export default Home;
```
In this example, the `DynamicComponent` is dynamically imported using the `dynamic` function from `next/dynamic`. This means that the component will only be loaded when it is needed, reducing the initial load time.

> In React, This is lengthy process to do this and the process is manual ,and we have to do lots of configuration as your application grows. But in NextJs it is very easy to do this and it is automatic.

```⚡ REACT```

For Example:-
We need to use calculate function to dynamically import the `Profile` component only when it is needed. This means that the `Profile` component will only be loaded when it is needed, reducing the initial load time.

```jsx
const Profile = calculate(() => import('../components/profile'));
```
We also use this suspense component to show a fallback ui when the component being loaded. This is useful when you want to show a loading indicator while the component is being loaded.

```jsx
const Profile = calculate(() => import('../components/profile'));

const Home = () => {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <Profile />
      </Suspense>
    </div>
  );
};
```

```⚡ NEXTJS```

In NextJs we don't need to do this lengthy process. We just need to import the component and use it. NextJs will automatically split the code into smaller chunks and only load the code that is needed for the current page.

- It user automatic code splitting by default to split pages into separate chunks. This means that each page will be loaded as a separate chunk, reducing the initial load time.
```jsx
import Profile from '../components/profile';

const Home = () => {
  return (
    <div>
      <Profile />
    </div>
  );
};
```
> When user navigate to the page, only the code required for that page will be loaded. This means that the initial load time will be reduced.

### ➡️ **SSG**
Static Site Generation (SSG) is a technique for generating static HTML files from a dynamic website. This is done by pre-rendering the HTML files on the server side and then serving them to the client side. This technique is used to improve the performance of a website by reducing the number of requests made to the server.

In Next.js, you can use the `getStaticProps` function to generate static HTML files for your website. This function is called at build time and it returns an object with the props that will be passed to the page component. The props are then used to generate the static HTML files for the website.

Here's an example of how to use `getStaticProps` in Next.js:
```jsx
// pages/index.js
export async function getStaticProps() {
  // Fetch data from an external API
  const res = await fetch('https://api.example.com/posts');
  const posts = await res.json();

  // Pass the data to the page via props
  return { props: { posts } };
}

const Home = ({ posts }) => {
  // Render the posts
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
};

export default Home;
```
In this example, the `getStaticProps` function fetches data from an external API and passes it to the page component via props. The data is then used to generate static HTML files for the website at build time.

## Conclusion

Next.js is an extension of React.js. It is a framework for building React applications. It provides a lot of features that make it easier to build React applications. It also provides a lot of performance optimizations that make it faster than React.




## ⚡ Installation ⚡

### ⚙️ ️How to Set Up a Next.js Project

- To start, create a folder and open it in your favorite code editor.
- Next, open the terminal and run this command to create a new Next.js project:
```jsx
npx create-next-app@latest ./
```
> The `./` means the current directory where your project will be created.
> The `@latest` means the latest version of Next.js.
- Then, you will be asked to choose some options:
  - Would you like to use TypeScript? (y/N)
    - TypeScript is a version of JavaScript that adds static type definitions to the language. This can help you catch errors and write better code. I chose Yes for this option.
  - Would you like to use ESLint with this project? (Y/n)
    - ESLint is a tool that checks your JavaScript code for common mistakes and style issues. It can help you improve your code quality and consistency. I chose No for this option.
  - Would you like to use Tailwind CSS with this project? (y/N)
    - Tailwind CSS is a framework that provides you with many ready-made CSS classes that you can use to style your components. It allows you to customize your design without writing too much CSS code. I chose Yes for this option.
  - Would you like to use `src/` directory with this project? (y/N)
    - This is a folder structure that is recommended when you have a large project. It helps you organize your files and folders better. I chose No for this option.
    - If you choose Yes, it will create a `src/` folder and move all the files into it.
  - Would you like to use experimental `app/` directory with this project? (Y/n)
    - This is a new feature in Next 13.4 that adds some benefits to your project, such as faster builds and better performance. I choose Yes for this option.
  - What import alias would you like to configure?
    - I choose yes for this option and then it will ask me to enter the alias name. I entered `@` for this option.
    - >This is an optional feature that lets you use shorter paths when importing modules in your project. For example, instead of writing `import Component from '../../components/Component'`, you can write `import Component from '@components/Component'`. I just pressed Enter for this option.
> **After that, it will install all the dependencies and create a new Next.js project for you.**

### 📁 Folder Structure

- After Installing Next.js, you will see the following folder structure:
`next 13.4`
```
├── .next
├── node_modules
├── public
|   ├── next.svg  
|   └── vercel.svg
├── app
|   ├── favicon.ico
|   ├── globals.css
|   ├── layout.tsx
|   └── page.tsx
├── .gitignore
├── next-env.d.ts
├── next.config.js
├── package-lock.json
├── package.json
├── postcss.config.js
├── README.md
├── tailwind.config.js
└── tsconfig.json
```
- `.next`: This folder contains the generated output of the Next.js application. It includes static files, server-side rendered pages, and other build artifacts. You should not modify this folder manually as it is overwritten by Next.js during development and production builds.
- `node_modules`: This folder contains the dependencies of the project that are installed by `npm` or `yarn`. You should not modify this folder manually as it is managed by the package manager.
- `public`: This folder contains static assets that can be accessed by the browser directly. You can place images, icons, fonts, or any other files that are not part of the Next.js pages or components in this folder. The files in this folder are served from the root path of the application, for example `/public/next.svg` can be accessed as `/next.svg`.
- `app`: This folder contains the source code of the Next.js application. You can create pages, components, hooks, or any other files that are part of the application logic in this folder. The files in this folder are processed by Next.js and transformed into JavaScript bundles that are sent to the browser or executed on the server.
  - `favicon.ico`: This file is the icon that appears in the browser tab when visiting the application. You can replace this file with your own icon if you want to customize it.
  - `globals.css`: This file contains global CSS styles that are applied to the entire application. You can use this file to define custom variables, fonts, resets, or any other styles that are not specific to a single page or component.
  - `layout.tsx`: The `layout.tsx` file is one of the most important files in our Next.js app. It is the main entry point of our application and it defines the common layout for all the pages. Any components we include in this file will be shared throughout our entire application. For example, we can use this file to render a navbar and a footer that will appear on every page. We can also use this file to customize the appearance and behavior of our HTML document. We can set the language attribute, modify the metadata, add script tags, links, fonts, or any other elements that we want to have in the head section of our document. We can also use this file to wrap our components with any providers or contexts that we need, such as Redux Toolkit or React Query. The `layout.tsx` file takes all the children components as props and renders them inside the layout. This way, we can create different pages with different content, but still use the same layout for all of them. In summary, the `layout.tsx` file is where we put anything that should stay consistent across all routes in our Next.js app.
  - `page.tsx`: The `page.tsx` file is another important file in our Next.js app. It defines the content and logic of the home page of our application. That is, it's what we see when we go to `localhost:3000/` or the root path of our app. In this file, we can use React components, hooks, or any other features to create our UI and functionality for the home page.You can also use this component to customize the head tags, title, meta tags, or other SEO attributes of each page using the `Head` component from Next.js. For example, we can fetch data, render a list of items, handle user input, or perform any other tasks that are specific to the home page. The `page.tsx` file is just a typical React component that returns some JSX elements. In this case, it's just a simple boilerplate code that shows a welcome message and some links. 
- `.gitignore`: This file tells Git which files or folders to ignore when committing changes to the repository. You can use this file to exclude files that are not part of the source code, such as `.next`, `node_modules`, `.env`, or any other files that contain sensitive or temporary information.
- `next-env.d.ts`: This file tells TypeScript which types to use for Next.js specific features, such as dynamic imports, image optimization, or custom server. You should not modify this file manually as it is generated by Next.js during development and production builds.
- `next.config.js`: This file allows you to configure various aspects of Next.js behavior, such as custom webpack configuration, runtime environment variables, redirects, rewrites, internationalization, or plugins. You can use this file to customize how Next.js builds and runs your application according to your needs.
- `package-lock.json`: This file locks the exact versions of the dependencies that are installed by `npm`. You should not modify this file manually as it is managed by `npm`. You should commit this file to your repository to ensure consistent installations across different environments.
- `package.json`: This file contains information about the project, such as name, version, description, scripts, dependencies, devDependencies, or any other metadata. You can use this file to define how to start, build, test, or deploy your application using `npm` scripts. You can also use this file to specify which dependencies are required for your application to run properly.
- `postcss.config.js`: This file allows you to configure PostCSS plugins that are used by Next.js to process CSS files. You can use this file to enable features such as Tailwind CSS, Autoprefixer, PurgeCSS, or any other PostCSS plugins that you want to use in your project.
- `README.md`: This file contains documentation about the project, such as how to install, run, test, or deploy it. You can use this file to explain what your project does, how it works, what technologies it uses, or any other information that you want to share with others who might use or contribute to your project.
- `tailwind.config.js`: This file allows you to configure Tailwind CSS options that are used by Next.js
